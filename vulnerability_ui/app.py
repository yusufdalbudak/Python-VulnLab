from flask import Flask, render_template, request, redirect, url_for, flash, session
import os

app = Flask(__name__)
app.secret_key = 'super-secret-key-for-demo-purposes-only'

# --- Routes ---

@app.route('/')
def index():
    return render_template('index.html')

# --- 01 Broken Authentication ---

fake_db = {
    "1": {"id": "1", "owner": "user_a", "data": "Sensitive Data for User A (Credit Card: ****-1234)"},
    "2": {"id": "2", "owner": "user_b", "data": "Sensitive Data for User B (SSN: ***-**-6789)"}
}

@app.route('/vuln/auth', methods=['GET', 'POST'])
def vuln_auth():
    result = None
    if request.method == 'POST':
        # Vulnerable Login Logic
        username = request.form.get('username')
        password = request.form.get('password')
        
        # VULNERABLE: Hardcoded, weak credentials, no rate limiting
        if username == "admin" and password == "123456":
            result = {"status": "success", "msg": "Login Successful! Token: admin_token_123"}
        else:
            result = {"status": "error", "msg": "Invalid Credentials"}
            
    return render_template('vuln_auth.html', login_result=result)

@app.route('/vuln/auth/invoice', methods=['POST'])
def vuln_auth_invoice():
    # VULNERABLE: BOLA / IDOR
    invoice_id = request.form.get('invoice_id')
    
    if invoice_id in fake_db:
        # No check if current user owns this invoice
        data = fake_db[invoice_id]
        return render_template('vuln_auth.html', invoice_result=data)
    else:
        return render_template('vuln_auth.html', invoice_result={"error": "Invoice not found"})

# --- 02 JWT Pitfalls ---
import jwt

JWT_SECRET = "weak_secret"

@app.route('/vuln/jwt', methods=['GET', 'POST'])
def vuln_jwt():
    gen_token = None
    verify_result = None
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'generate':
            # VULNERABLE: Sensitive data in payload
            payload = {"sub": "user_123", "role": "user", "credit_card": "4111-2222-3333-4444"}
            gen_token = jwt.encode(payload, JWT_SECRET, algorithm="HS256")
            
        elif action == 'verify':
            token = request.form.get('token')
            token = request.form.get('token')
            try:
                # VULNERABLE: Allows 'none' algorithm
                # Modern PyJWT is strict, so we manually check for 'none' alg to simulate the vulnerability
                unverified_header = jwt.get_unverified_header(token)
                
                if unverified_header.get('alg') == 'none':
                    # Simulate vulnerability: Don't verify signature if alg is none
                    decoded = jwt.decode(token, options={"verify_signature": False})
                else:
                    # Normal verification
                    decoded = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
                
                verify_result = {"status": "success", "payload": decoded}
            except Exception as e:
                verify_result = {"status": "error", "msg": str(e)}

    return render_template('vuln_jwt.html', gen_token=gen_token, verify_result=verify_result)

# --- 03 Injection Attacks ---
import sqlite3
import subprocess

def init_db():
    conn = sqlite3.connect(':memory:')
    c = conn.cursor()
    c.execute('CREATE TABLE users (id INTEGER PRIMARY KEY, username TEXT, password TEXT)')
    c.execute("INSERT INTO users (username, password) VALUES ('admin', 'secret_admin_pass')")
    c.execute("INSERT INTO users (username, password) VALUES ('alice', 'alice_pass')")
    c.execute("INSERT INTO users (username, password) VALUES ('bob', 'bob_pass')")
    conn.commit()
    return conn

@app.route('/vuln/injection', methods=['GET', 'POST'])
def vuln_injection():
    sql_result = None
    cmd_result = None
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'sql':
            username = request.form.get('username')
            # VULNERABLE: SQL Injection
            conn = init_db()
            try:
                query = f"SELECT * FROM users WHERE username = '{username}'"
                sql_result = {"query": query, "data": conn.execute(query).fetchall()}
            except Exception as e:
                sql_result = {"query": query, "error": str(e)}
            finally:
                conn.close()
                
        elif action == 'cmd':
            hostname = request.form.get('hostname')
            # VULNERABLE: Command Injection
            # Using subprocess.getoutput to capture output for demo
            try:
                # Limit execution time to avoid hanging
                cmd = f"ping -c 1 {hostname}"
                cmd_result = {"cmd": cmd, "output": subprocess.getoutput(cmd)}
            except Exception as e:
                cmd_result = {"cmd": cmd, "error": str(e)}

    return render_template('vuln_injection.html', sql_result=sql_result, cmd_result=cmd_result)

# --- 04 Insecure Deserialization ---
import pickle
import base64
import yaml

@app.route('/vuln/serialization', methods=['GET', 'POST'])
def vuln_serialization():
    result = None
    
    if request.method == 'POST':
        action = request.form.get('action')
        
        if action == 'pickle':
            payload = request.form.get('payload')
            try:
                # VULNERABLE: Pickle deserialization
                # Expecting base64 encoded pickle data
                data = base64.b64decode(payload)
                obj = pickle.loads(data)
                result = {"type": "pickle", "status": "success", "msg": f"Successfully deserialized object: {obj}"}
            except Exception as e:
                result = {"type": "pickle", "status": "error", "msg": str(e)}
                
        elif action == 'yaml':
            payload = request.form.get('payload')
            try:
                # VULNERABLE: Unsafe YAML loading
                # Loader=yaml.Loader is unsafe in PyYAML
                obj = yaml.load(payload, Loader=yaml.Loader)
                result = {"type": "yaml", "status": "success", "msg": f"Successfully deserialized YAML: {obj}"}
            except Exception as e:
                result = {"type": "yaml", "status": "error", "msg": str(e)}

    return render_template('vuln_serialization.html', result=result)

# --- 05 Rate Limiting ---
import time

@app.route('/vuln/ratelimit')
def vuln_ratelimit():
    return render_template('vuln_ratelimit.html')

@app.route('/vuln/ratelimit/heavy', methods=['POST'])
def vuln_ratelimit_heavy():
    # VULNERABLE: No rate limit, resource exhaustion
    # Simulating heavy work
    time.sleep(2) 
    return {"status": "success", "msg": "Heavy report generated!"}

# --- 06 Security Misconfiguration ---

@app.route('/vuln/misconfig')
def vuln_misconfig():
    # VULNERABLE: Exposing sensitive config in a "debug" view
    config_dump = {
        "DEBUG": True,
        "SECRET_KEY": app.secret_key,
        "DB_PASSWORD": "hardcoded_db_password",
        "AWS_ACCESS_KEY": "AKIAIOSFODNN7EXAMPLE"
    }
    return render_template('vuln_misconfig.html', config=config_dump)

@app.route('/vuln/misconfig/error')
def vuln_misconfig_error():
    # VULNERABLE: Unhandled exception showing stack trace (simulated)
    # In a real Flask app with debug=True, this would show the interactive debugger.
    # We will simulate a stack trace here.
    try:
        1 / 0
    except Exception as e:
        import traceback
        return f"<pre>{traceback.format_exc()}</pre>", 500

# --- 08 API Sprawl ---

@app.route('/vuln/sprawl')
def vuln_sprawl():
    return render_template('vuln_sprawl.html')

@app.route('/api/v1/users')
def api_v1_users():
    # VULNERABLE: Deprecated, unmaintained, no auth
    return {"version": "v1", "users": [{"id": 1, "name": "admin", "role": "superuser"}]}

@app.route('/api/v2/users')
def api_v2_users():
    # SECURE: Requires auth (simulated)
    auth_header = request.headers.get('Authorization')
    if auth_header != "Bearer secure_token":
        return {"error": "Unauthorized"}, 401
    return {"version": "v2", "users": [{"id": 1, "name": "admin"}]}

@app.route('/test_debug_endpoint')
def test_debug_endpoint():
    # VULNERABLE: Shadow API, undocumented
    return {"system_env": "production", "internal_ip": "10.0.0.5"}

if __name__ == '__main__':
    app.run(debug=True, port=5000)
